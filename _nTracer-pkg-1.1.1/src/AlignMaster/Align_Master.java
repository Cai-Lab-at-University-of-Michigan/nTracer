/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package AlignMaster;

/*
 * Align_Master 1.0.5
 *
 * Created on May 21, 2018
 */
/**
 * Ver 1.0.2 - This ImageJ plugin contains two modules, "Channel Registration" and "3D Stitching"
 *             
 *             "Channel Registration" corrects color shift caused by pixel misregistration in
 *             different color channels of a multi-channel Composite Image. Correction is done by 
 *             translational shifting other channels laterally and axially in full pixels, relative 
 *             to the user selected reference channel.
 * 
 *             "3D Stitching" merges two adjacent image tiles by translational shifting the other 
 *             image stack laterally and axially and stitch it to the reference image.
 * 
 * Ver 1.0.3 - Add histogram matching (multi-threading, batch process) to correct intensity change in z axis
 * 
 * Ver 1.0.4 - Save coordinate shift (translation) results.
 * 
 * Ver 1.0.5 - Fix exception bugs. Works with ImageJ1.52b with imagescience.jar; Do not use Fiji!
             - Fix coordinate bugs
 * 
 * Todo: 
 * 
 * Ver 1.0.6 - Ratio or histogram normalization to correct intensity fall off at image edges (match background).
 *             Match intensity in 3D Stitching (image fusion).
 * 
 * Ver 1.1.0 - Improve channel alignment and stitching speed - JCuda; FFT-crosscorrelation
 *                   Nonlinear correction for "Channel Registration" and "3D Stitching" in all axial directions.
 *                   Perfect channel match, seamless stitching.
 */
/**
 *
 * @author Dawen Cai (dwcai@umich.edu)
 * @author Department of Cell and Developmental Biology
 * @author Medical School, University of Michigan
 * @author Ann Arbor, MI
 *
 */

import nTracer.ntIO;
import ij.IJ;
import ij.ImagePlus;
import ij.CompositeImage;
import ij.ImageStack;
import ij.io.SaveDialog;
import ij.WindowManager;
import ij.gui.PointRoi;
import ij.gui.Roi;
import ij.gui.Toolbar;
import ij.io.DirectoryChooser;
import ij.io.OpenDialog;
import ij.plugin.Duplicator;
import ij.process.ImageProcessor;

import java.awt.Rectangle;
//import java.awt.Desktop;
//import java.net.URL;
import java.io.*;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.Scanner;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import javax.swing.JFileChooser;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileNameExtensionFilter;

public class Align_Master extends javax.swing.JFrame {

    /**
     * Creates new form (GUI) ColorChannel_Alignment
     */
    public Align_Master() {
        if (IJ.isJava18()) {
            initComponents();
            //action_jTabbedPane.setSelectedIndex(1);
            Toolbar.getInstance().setTool("point");
            this.setVisible(true);
            fc = new AMfunctions();
            maxXYshift = (Integer) ((maxXYshiftComboBox.getSelectedIndex() + 1) * 10);
            maxZshift = (Integer) ((maxZshiftComboBox.getSelectedIndex() + 1) * 10);
            // set up system look and feel
            try {
                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | UnsupportedLookAndFeelException ex) {
            }

            System.setProperty("apple.laf.useScreenMenuBar", "true");
        } else {
            fc = new AMfunctions();
            IJ.error("Fiji/ImageJ-Java8 version is required !");
        }    
    }
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fileChooser = new javax.swing.JFileChooser();
        maxXYshiftComboBox = new javax.swing.JComboBox();
        maxXYshiftLabel = new javax.swing.JLabel();
        maxZshiftLabel = new javax.swing.JLabel();
        action_jTabbedPane = new javax.swing.JTabbedPane();
        colorNormalization_jPanel = new javax.swing.JPanel();
        histogramMatching_jPanel = new javax.swing.JPanel();
        histogramMatchOpenedButton = new javax.swing.JButton();
        histogramMatchBatchButton = new javax.swing.JButton();
        histogramMatchSubfolderCheckBox = new javax.swing.JCheckBox();
        hmParameter_jPanel = new javax.swing.JPanel();
        hmReferenceImage_jToggleButton = new javax.swing.JToggleButton();
        highContrast_jCheckBox = new javax.swing.JCheckBox();
        registration_jPanel = new javax.swing.JPanel();
        registrationMatrix_jPanel = new javax.swing.JPanel();
        calculateRegistrationButton = new javax.swing.JButton();
        saveRegistrationButton = new javax.swing.JButton();
        loadRegistrationButton = new javax.swing.JButton();
        register_jPanel = new javax.swing.JPanel();
        registerBatchButton = new javax.swing.JButton();
        registerOpenedButton = new javax.swing.JButton();
        registerSubfolderCheckBox = new javax.swing.JCheckBox();
        result_jScrollPane = new javax.swing.JScrollPane();
        chRegResult_jTextArea = new javax.swing.JTextArea();
        stitching_jPanel = new javax.swing.JPanel();
        topLeftImage_jToggleButton = new javax.swing.JToggleButton();
        topRightImage_jToggleButton = new javax.swing.JToggleButton();
        bottomLeftImage_jToggleButton = new javax.swing.JToggleButton();
        bottomRightImage_jToggleButton = new javax.swing.JToggleButton();
        stitchOpenedButton = new javax.swing.JButton();
        saveStitchingMatrixButton = new javax.swing.JButton();
        loadStitchingMatrixButton = new javax.swing.JButton();
        calculateStichingButton = new javax.swing.JButton();
        stitchingResult_jScrollPane = new javax.swing.JScrollPane();
        stitchingResult_jTextArea = new javax.swing.JTextArea();
        translateResult_jPanel = new javax.swing.JPanel();
        xTranslation_jTextField = new javax.swing.JTextField();
        xTranslation_jLabel = new javax.swing.JLabel();
        xPixels_jLabel = new javax.swing.JLabel();
        yPixels_jLabel = new javax.swing.JLabel();
        yTranslation_jTextField = new javax.swing.JTextField();
        yTranslation_jLabel = new javax.swing.JLabel();
        zPixels_jLabel = new javax.swing.JLabel();
        zTranslation_jTextField = new javax.swing.JTextField();
        zTranslation_jLabel = new javax.swing.JLabel();
        translate_jButton = new javax.swing.JButton();
        manual_jButton = new javax.swing.JButton();
        maxZshiftComboBox = new javax.swing.JComboBox();
        pixelShiftLabel2 = new javax.swing.JLabel();

        fileChooser.setFileFilter(new FileNameExtensionFilter("*.txt", "txt"));

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Align Master-1.0.6");
        setResizable(false);

        maxXYshiftComboBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        maxXYshiftComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "10", "20", "30", "40", "50" }));
        maxXYshiftComboBox.setSelectedIndex(1);
        maxXYshiftComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                maxXYshiftComboBoxActionPerformed(evt);
            }
        });

        maxXYshiftLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        maxXYshiftLabel.setText("Max Shift: XY =");

        maxZshiftLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        maxZshiftLabel.setText("Pixels;   Z =");

        histogramMatching_jPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)), "Histogram Matching", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 11))); // NOI18N

        histogramMatchOpenedButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        histogramMatchOpenedButton.setForeground(new java.awt.Color(255, 0, 0));
        histogramMatchOpenedButton.setText("Opened");
        histogramMatchOpenedButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        histogramMatchOpenedButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                histogramMatchOpenedButtonActionPerformed(evt);
            }
        });

        histogramMatchBatchButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        histogramMatchBatchButton.setForeground(new java.awt.Color(255, 0, 0));
        histogramMatchBatchButton.setText("Batch");
        histogramMatchBatchButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        histogramMatchBatchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                histogramMatchBatchButtonActionPerformed(evt);
            }
        });

        histogramMatchSubfolderCheckBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        histogramMatchSubfolderCheckBox.setForeground(new java.awt.Color(255, 0, 0));
        histogramMatchSubfolderCheckBox.setText("subfolder");
        histogramMatchSubfolderCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        hmParameter_jPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)), "Match to ..."));

        hmReferenceImage_jToggleButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        hmReferenceImage_jToggleButton.setText("Reference Image");
        hmReferenceImage_jToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                hmReferenceImage_jToggleButtonActionPerformed(evt);
            }
        });

        highContrast_jCheckBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        highContrast_jCheckBox.setText("High Contrast Histogram");
        highContrast_jCheckBox.setEnabled(false);

        javax.swing.GroupLayout hmParameter_jPanelLayout = new javax.swing.GroupLayout(hmParameter_jPanel);
        hmParameter_jPanel.setLayout(hmParameter_jPanelLayout);
        hmParameter_jPanelLayout.setHorizontalGroup(
            hmParameter_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(hmParameter_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(hmParameter_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(highContrast_jCheckBox, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(hmReferenceImage_jToggleButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        hmParameter_jPanelLayout.setVerticalGroup(
            hmParameter_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(hmParameter_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(hmReferenceImage_jToggleButton, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)
                .addComponent(highContrast_jCheckBox)
                .addContainerGap())
        );

        javax.swing.GroupLayout histogramMatching_jPanelLayout = new javax.swing.GroupLayout(histogramMatching_jPanel);
        histogramMatching_jPanel.setLayout(histogramMatching_jPanelLayout);
        histogramMatching_jPanelLayout.setHorizontalGroup(
            histogramMatching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(histogramMatching_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(histogramMatching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(histogramMatching_jPanelLayout.createSequentialGroup()
                        .addComponent(histogramMatchOpenedButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(histogramMatching_jPanelLayout.createSequentialGroup()
                        .addGroup(histogramMatching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(hmParameter_jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(histogramMatching_jPanelLayout.createSequentialGroup()
                                .addComponent(histogramMatchBatchButton, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(5, 5, 5)
                                .addComponent(histogramMatchSubfolderCheckBox)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        histogramMatching_jPanelLayout.setVerticalGroup(
            histogramMatching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(histogramMatching_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(hmParameter_jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(histogramMatchOpenedButton, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(27, 27, 27)
                .addGroup(histogramMatching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(histogramMatchBatchButton)
                    .addComponent(histogramMatchSubfolderCheckBox))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        histogramMatching_jPanelLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {histogramMatchBatchButton, histogramMatchOpenedButton});

        javax.swing.GroupLayout colorNormalization_jPanelLayout = new javax.swing.GroupLayout(colorNormalization_jPanel);
        colorNormalization_jPanel.setLayout(colorNormalization_jPanelLayout);
        colorNormalization_jPanelLayout.setHorizontalGroup(
            colorNormalization_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(colorNormalization_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(histogramMatching_jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(318, Short.MAX_VALUE))
        );
        colorNormalization_jPanelLayout.setVerticalGroup(
            colorNormalization_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(colorNormalization_jPanelLayout.createSequentialGroup()
                .addComponent(histogramMatching_jPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        action_jTabbedPane.addTab("Intensity/Color Normalization", colorNormalization_jPanel);

        registrationMatrix_jPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)), "Transformation Matrix"));

        calculateRegistrationButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        calculateRegistrationButton.setForeground(new java.awt.Color(0, 102, 51));
        calculateRegistrationButton.setText("Calculate");
        calculateRegistrationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calculateRegistrationButtonActionPerformed(evt);
            }
        });

        saveRegistrationButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        saveRegistrationButton.setForeground(new java.awt.Color(0, 102, 51));
        saveRegistrationButton.setText("Save");
        saveRegistrationButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        saveRegistrationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveRegistrationButtonActionPerformed(evt);
            }
        });

        loadRegistrationButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        loadRegistrationButton.setForeground(new java.awt.Color(0, 102, 51));
        loadRegistrationButton.setText("Load");
        loadRegistrationButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        loadRegistrationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadRegistrationButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout registrationMatrix_jPanelLayout = new javax.swing.GroupLayout(registrationMatrix_jPanel);
        registrationMatrix_jPanel.setLayout(registrationMatrix_jPanelLayout);
        registrationMatrix_jPanelLayout.setHorizontalGroup(
            registrationMatrix_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(registrationMatrix_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(calculateRegistrationButton, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(saveRegistrationButton, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(loadRegistrationButton, javax.swing.GroupLayout.PREFERRED_SIZE, 48, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        registrationMatrix_jPanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {loadRegistrationButton, saveRegistrationButton});

        registrationMatrix_jPanelLayout.setVerticalGroup(
            registrationMatrix_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(registrationMatrix_jPanelLayout.createSequentialGroup()
                .addGroup(registrationMatrix_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(registrationMatrix_jPanelLayout.createSequentialGroup()
                        .addGroup(registrationMatrix_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(saveRegistrationButton)
                            .addComponent(loadRegistrationButton))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(calculateRegistrationButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        register_jPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)), "Register"));

        registerBatchButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        registerBatchButton.setForeground(new java.awt.Color(255, 0, 0));
        registerBatchButton.setText("Batch");
        registerBatchButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        registerBatchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                registerBatchButtonActionPerformed(evt);
            }
        });

        registerOpenedButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        registerOpenedButton.setForeground(new java.awt.Color(255, 0, 0));
        registerOpenedButton.setText("Opened");
        registerOpenedButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        registerOpenedButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                registerOpenedButtonActionPerformed(evt);
            }
        });

        registerSubfolderCheckBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        registerSubfolderCheckBox.setForeground(new java.awt.Color(255, 0, 0));
        registerSubfolderCheckBox.setText("subfolder");
        registerSubfolderCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        javax.swing.GroupLayout register_jPanelLayout = new javax.swing.GroupLayout(register_jPanel);
        register_jPanel.setLayout(register_jPanelLayout);
        register_jPanelLayout.setHorizontalGroup(
            register_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(register_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(registerOpenedButton, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(registerBatchButton, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(registerSubfolderCheckBox)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        register_jPanelLayout.setVerticalGroup(
            register_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(register_jPanelLayout.createSequentialGroup()
                .addGroup(register_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(registerBatchButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(registerOpenedButton)
                    .addComponent(registerSubfolderCheckBox))
                .addContainerGap())
        );

        result_jScrollPane.setBorder(null);

        chRegResult_jTextArea.setEditable(false);
        chRegResult_jTextArea.setBackground(new java.awt.Color(240, 240, 240));
        chRegResult_jTextArea.setColumns(20);
        chRegResult_jTextArea.setRows(5);
        chRegResult_jTextArea.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)), "Result"));
        result_jScrollPane.setViewportView(chRegResult_jTextArea);

        javax.swing.GroupLayout registration_jPanelLayout = new javax.swing.GroupLayout(registration_jPanel);
        registration_jPanel.setLayout(registration_jPanelLayout);
        registration_jPanelLayout.setHorizontalGroup(
            registration_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(registration_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(registration_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(result_jScrollPane)
                    .addGroup(registration_jPanelLayout.createSequentialGroup()
                        .addComponent(registrationMatrix_jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(register_jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        registration_jPanelLayout.setVerticalGroup(
            registration_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(registration_jPanelLayout.createSequentialGroup()
                .addGroup(registration_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(registrationMatrix_jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(register_jPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(result_jScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 198, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        action_jTabbedPane.addTab("Channel Registration", registration_jPanel);

        topLeftImage_jToggleButton.setText(" ");
        topLeftImage_jToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                topLeftImage_jToggleButtonActionPerformed(evt);
            }
        });

        topRightImage_jToggleButton.setText(" ");
        topRightImage_jToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                topRightImage_jToggleButtonActionPerformed(evt);
            }
        });

        bottomLeftImage_jToggleButton.setText(" ");
        bottomLeftImage_jToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bottomLeftImage_jToggleButtonActionPerformed(evt);
            }
        });

        bottomRightImage_jToggleButton.setText(" ");
        bottomRightImage_jToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bottomRightImage_jToggleButtonActionPerformed(evt);
            }
        });

        stitchOpenedButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        stitchOpenedButton.setForeground(new java.awt.Color(255, 0, 0));
        stitchOpenedButton.setText("Stitch Opened");
        stitchOpenedButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        stitchOpenedButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stitchOpenedButtonActionPerformed(evt);
            }
        });

        saveStitchingMatrixButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        saveStitchingMatrixButton.setForeground(new java.awt.Color(0, 102, 51));
        saveStitchingMatrixButton.setText("Save");
        saveStitchingMatrixButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        saveStitchingMatrixButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveStitchingMatrixButtonActionPerformed(evt);
            }
        });

        loadStitchingMatrixButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        loadStitchingMatrixButton.setForeground(new java.awt.Color(0, 102, 51));
        loadStitchingMatrixButton.setText("Load");
        loadStitchingMatrixButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        loadStitchingMatrixButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadStitchingMatrixButtonActionPerformed(evt);
            }
        });

        calculateStichingButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        calculateStichingButton.setForeground(new java.awt.Color(0, 102, 51));
        calculateStichingButton.setText("Calculate Matrix");
        calculateStichingButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        calculateStichingButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calculateStichingButtonActionPerformed(evt);
            }
        });

        stitchingResult_jScrollPane.setBorder(null);

        stitchingResult_jTextArea.setEditable(false);
        stitchingResult_jTextArea.setBackground(new java.awt.Color(240, 240, 240));
        stitchingResult_jTextArea.setColumns(20);
        stitchingResult_jTextArea.setRows(5);
        stitchingResult_jTextArea.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)), "Result"));
        stitchingResult_jTextArea.setMinimumSize(new java.awt.Dimension(10, 20));
        stitchingResult_jTextArea.setPreferredSize(new java.awt.Dimension(170, 60));
        stitchingResult_jScrollPane.setViewportView(stitchingResult_jTextArea);

        javax.swing.GroupLayout stitching_jPanelLayout = new javax.swing.GroupLayout(stitching_jPanel);
        stitching_jPanel.setLayout(stitching_jPanelLayout);
        stitching_jPanelLayout.setHorizontalGroup(
            stitching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(stitching_jPanelLayout.createSequentialGroup()
                .addContainerGap(125, Short.MAX_VALUE)
                .addComponent(stitchOpenedButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(stitching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(saveStitchingMatrixButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(loadStitchingMatrixButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(calculateStichingButton, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(stitching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(stitching_jPanelLayout.createSequentialGroup()
                        .addComponent(bottomLeftImage_jToggleButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(bottomRightImage_jToggleButton))
                    .addGroup(stitching_jPanelLayout.createSequentialGroup()
                        .addComponent(topLeftImage_jToggleButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(topRightImage_jToggleButton)))
                .addGap(27, 27, 27))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, stitching_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(stitchingResult_jScrollPane)
                .addContainerGap())
        );
        stitching_jPanelLayout.setVerticalGroup(
            stitching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(stitching_jPanelLayout.createSequentialGroup()
                .addGroup(stitching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(topLeftImage_jToggleButton, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(topRightImage_jToggleButton, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(calculateStichingButton, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(saveStitchingMatrixButton, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(stitching_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bottomLeftImage_jToggleButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(bottomRightImage_jToggleButton, javax.swing.GroupLayout.DEFAULT_SIZE, 31, Short.MAX_VALUE)
                    .addComponent(loadStitchingMatrixButton, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(stitchOpenedButton, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stitchingResult_jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 160, Short.MAX_VALUE)
                .addContainerGap())
        );

        stitching_jPanelLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {bottomLeftImage_jToggleButton, bottomRightImage_jToggleButton, topLeftImage_jToggleButton, topRightImage_jToggleButton});

        action_jTabbedPane.addTab("3D Stitching", stitching_jPanel);

        xTranslation_jTextField.setText("0");

        xTranslation_jLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        xTranslation_jLabel.setText("X translation :");

        xPixels_jLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        xPixels_jLabel.setText("pixels");

        yPixels_jLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        yPixels_jLabel.setText("pixels");

        yTranslation_jTextField.setText("0");

        yTranslation_jLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        yTranslation_jLabel.setText("Y translation :");

        zPixels_jLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        zPixels_jLabel.setText("pixels");

        zTranslation_jTextField.setText("0");

        zTranslation_jLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        zTranslation_jLabel.setText("Z translation :");

        translate_jButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        translate_jButton.setForeground(new java.awt.Color(0, 102, 51));
        translate_jButton.setText("Translate");
        translate_jButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        translate_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                translate_jButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout translateResult_jPanelLayout = new javax.swing.GroupLayout(translateResult_jPanel);
        translateResult_jPanel.setLayout(translateResult_jPanelLayout);
        translateResult_jPanelLayout.setHorizontalGroup(
            translateResult_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, translateResult_jPanelLayout.createSequentialGroup()
                .addContainerGap(251, Short.MAX_VALUE)
                .addGroup(translateResult_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(translate_jButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(translateResult_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(translateResult_jPanelLayout.createSequentialGroup()
                            .addComponent(zTranslation_jLabel)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(zTranslation_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(zPixels_jLabel))
                        .addGroup(translateResult_jPanelLayout.createSequentialGroup()
                            .addComponent(yTranslation_jLabel)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(yTranslation_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(yPixels_jLabel))
                        .addGroup(translateResult_jPanelLayout.createSequentialGroup()
                            .addComponent(xTranslation_jLabel)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(xTranslation_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(xPixels_jLabel))))
                .addGap(122, 122, 122))
        );
        translateResult_jPanelLayout.setVerticalGroup(
            translateResult_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(translateResult_jPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(translateResult_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(xTranslation_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(xTranslation_jLabel)
                    .addComponent(xPixels_jLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(translateResult_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(yTranslation_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(yTranslation_jLabel)
                    .addComponent(yPixels_jLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(translateResult_jPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(zTranslation_jTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(zTranslation_jLabel)
                    .addComponent(zPixels_jLabel))
                .addGap(18, 18, 18)
                .addComponent(translate_jButton, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(129, Short.MAX_VALUE))
        );

        action_jTabbedPane.addTab("translate tracing result", translateResult_jPanel);

        manual_jButton.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        manual_jButton.setText("Manual");
        manual_jButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        manual_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                manual_jButtonActionPerformed(evt);
            }
        });

        maxZshiftComboBox.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        maxZshiftComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "5", "10", "15", "20" }));
        maxZshiftComboBox.setSelectedIndex(0);
        maxZshiftComboBox.setSelectedItem("3");
        maxZshiftComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                maxZshiftComboBoxActionPerformed(evt);
            }
        });

        pixelShiftLabel2.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        pixelShiftLabel2.setText("Pixels");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(action_jTabbedPane)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(maxXYshiftLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(maxXYshiftComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(maxZshiftLabel)
                        .addGap(2, 2, 2)
                        .addComponent(maxZshiftComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(pixelShiftLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(manual_jButton, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(maxZshiftComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(pixelShiftLabel2)
                        .addComponent(manual_jButton))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(maxXYshiftLabel)
                        .addComponent(maxXYshiftComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(maxZshiftLabel)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(action_jTabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, 290, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void maxXYshiftComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_maxXYshiftComboBoxActionPerformed
        maxXYshift = (Integer) ((maxXYshiftComboBox.getSelectedIndex()+1) * 10);
    }//GEN-LAST:event_maxXYshiftComboBoxActionPerformed

    private void calculateRegistrationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calculateRegistrationButtonActionPerformed
        // Make sure the selected image is a multichannel (>1) CompositeImage
        ImagePlus imp = WindowManager.getCurrentImage();
        if (imp == null) {
            IJ.error("No image opened!");
            return;
        }
        if (!imp.isComposite()) {
            IJ.error("Composite image reuired!");
            return;
        }
        if (imp.getNChannels() < 2) {
            IJ.error("Image must contain 2 or more channels.");
            return;
        }
        if (IJ.getToolName()!="point"){
            IJ.error("Please use pointROI tool to select one point from image.");
            return;
        }
        if (chRegTransformMethod.equals("Translation")) {
            translationMethod3D(imp);
            //translationMethod2Dthen1D(imp);
        }
        if (chRegTransformMethod.equals("Affine")) {
            IJ.error("Coming soon ...");
            //transformMatrix = fc.getTransformMatrix(imp, imp.getC());
            //fc.midsliceAlignment(imp, transformMatrix);
            //updateTextArea(transformMatrix);
        }
}//GEN-LAST:event_calculateRegistrationButtonActionPerformed

    private void translationMethod3D(ImagePlus imp) {
        if (imp.getNChannels()==1){
            IJ.error("This plugin aligns images have more than one channel !");
            return;
        }
        if (imp.getRoi()==null){
            IJ.error("Please use point selection tool to point a position that has signal in all channels !");
            return;
        }
        if (imp.getRoi().isArea() || imp.getRoi().isLine()){
            IJ.error("Please use point selection tool to point a position that has signal in all channels !");
            return;
        }
        double accuracy = 1;
        ImagePlus roiCropPadImg = fc.getAllChannelRoiCropImg(imp, maxXYshift, maxZshift);
        int refCh = imp.getC();
        chRegMatrix = new double[roiCropPadImg.getNChannels() + 1][4];
        chRegMatrix[refCh][0] = 0;
        chRegMatrix[refCh][1] = 0;
        chRegMatrix[refCh][2] = 0;
        chRegMatrix[refCh][3] = 1;
        for (int c = 1; c <= imp.getNChannels(); c++) {
            if (c != refCh) {
                ImagePlus impWork = fc.getStackingRefAlgImg(roiCropPadImg, refCh, c, maxXYshift, maxZshift);
                double[][] cMatrix = fc.getNoMaskTranslateMatrix(impWork, 1, maxXYshift, maxZshift, accuracy);
                chRegMatrix[c][0] = cMatrix[2][0];
                chRegMatrix[c][1] = cMatrix[2][1];
                chRegMatrix[c][2] = cMatrix[2][2];
                chRegMatrix[c][3] = cMatrix[2][3];
                impWork.close();
            }
        }
        updateChRegResult(chRegMatrix);
        roiCropPadImg.show();
        fc.doChannelRegistrationMultiThread(roiCropPadImg, chRegMatrix);
        roiCropPadImg.updateAndDraw();
        roiCropPadImg.setZ(roiCropPadImg.getNSlices()/2);
        roiCropPadImg.setTitle("Channel Aligned");
        
/*
        // generate a mask that thresholds pixels containing
        // intensity in all channels for more reliable and sensitive alignment
        ImagePlus mask = fc.generateMask(impROI, (int) maxXYshift);

        // obtain best pixel shift results and show in text panel
        // reference channel is the currently selected channel (imp.getC)
        translationMatrix = fc.getMaskedTranslateMatrix(impROI, mask, imp.getC(), 
                maxXYshift, maxZshift);
        fc.doChannelRegistrationMultiThread(impROI, chAlignmentMatrix);
*/
    }

    private void loadRegistrationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadRegistrationButtonActionPerformed
        try {
            chRegMatrix = parseChRegMatrixformFile();
            updateChRegResult(chRegMatrix);
        } catch (IOException e) {
        }
    }//GEN-LAST:event_loadRegistrationButtonActionPerformed

    private void registerOpenedButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_registerOpenedButtonActionPerformed
        if (chRegMatrix == null) {
            IJ.error("Load transformation matrix first!");
            return;
        }
        ImagePlus imp = WindowManager.getCurrentImage();
        if (imp == null) {
            IJ.error("No image opened!");
            return;
        }
        if (!imp.isComposite()) {
            IJ.error("Composite image reuired!");
            return;
        }
        if (imp.getNChannels() < 2) {
            IJ.error("Image must contain 2 or more channels.");
            return;
        }

        Roi currentROI = imp.getRoi();
        imp.killRoi();
        ImagePlus reg = imp.duplicate();
        reg.show();
        reg.setTitle(imp.getTitle()+"_Color Channel Aligned");
        fc.doChannelRegistrationMultiThread(reg, chRegMatrix);
        reg.updateAndDraw();
        reg.setZ((int)reg.getNSlices()/2);
        reg.setZ(imp.getZ());
        //CompositeImage cmp = (new CompositeImage(imp.duplicate(), CompositeImage.COMPOSITE));
        imp.setRoi(currentROI);
        //cmp.show();
        //cmp.setTitle("Color Channel Aligned");
        //fc.doChannelRegistrationMultiThread(cmp, chRegMatrix);
        //cmp.updateAndDraw();
        //cmp.setZ((int)cmp.getNSlices()/2);
        //cmp.setZ(imp.getZ());
    }//GEN-LAST:event_registerOpenedButtonActionPerformed

    private void registerBatchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_registerBatchButtonActionPerformed
        if (chRegMatrix == null) {
            IJ.error("Load transformation matrix first!");
            return;
        }
        DirectoryChooser dc = new DirectoryChooser("Choose a Folder ...");
        String selectedFolderPath = dc.getDirectory();
        if (selectedFolderPath != null) {
            batchChannelRegister(selectedFolderPath);
        }
    }//GEN-LAST:event_registerBatchButtonActionPerformed
    private void batchChannelRegister(String folderPath) {
        File selectedFolder = new File(folderPath);
        String rootDirectory = selectedFolder.getAbsolutePath();
        IJ.log("Channel Registration Starting directory: " + rootDirectory + newline + newline);
        try {
            batchTransformSubfolder(selectedFolder, rootDirectory, registerSubfolderCheckBox.isSelected());
        } catch (IOException e) {
            IJ.log(e.getMessage() + newline + newline);
        }
    }
    private void batchTransformSubfolder(File selectedFolder, 
            String rootDirectory, boolean transformSubfolder) throws IOException {
        File multFiles[] = selectedFolder.listFiles();
        ArrayList<File> tifFileList = new ArrayList<>();
        ArrayList<File> subfolderList = new ArrayList<>();
        for (File file : multFiles) {
            if (file.isFile()) {
                if (file.getName().endsWith(".tif") && !file.getName().endsWith("_ChReg.tif")) {
                    tifFileList.add(file);
                }
            } else if (transformSubfolder) {
                subfolderList.add(file);
            }
        }

        tifFileList.stream().forEach((file) -> {
            String relative = (new File(rootDirectory)).toURI().relativize(file.toURI()).getPath();
            IJ.log("..\\" + relative);
            if (transformImage(file.getAbsolutePath())) {
                IJ.log("Success!");
            } else {
                IJ.log("Fail!");
            }
        });

        if (transformSubfolder) {
            for (File file : subfolderList) {
                IJ.log("");
                batchTransformSubfolder(file, rootDirectory, transformSubfolder);
            }
        }
    }
    private boolean transformImage(String path) {
        ImagePlus imp = IJ.openImage(path);
        if (imp == null) {
            IJ.log("is Not a supported image file!");
            return false;
        }
        if (!imp.isComposite()) {
            IJ.log("is Not a Composite image!");
            return false;
        }
        if (imp.getNChannels() < 2) {
            IJ.log("contains less than 2 channels!");
            return false;
        }

        CompositeImage cmp = (new CompositeImage(imp, CompositeImage.COMPOSITE));
        cmp.show();
        String title = imp.getTitle();
        if (title.endsWith(".tif")) {
                title = title.substring(0, title.length() - 4);
            }
        cmp.setTitle(title+"_ChReg.tif");
        fc.doChannelRegistrationMultiThread(cmp, chRegMatrix);
        //fc.doCorrectionFile(cmp, chRegMatrix);
        IJ.save(cmp, new File(path).getParent()+"/"+cmp.getTitle());
        cmp.close();
        imp.flush();
        cmp.flush();
        return true;
    }
    
    private void saveRegistrationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveRegistrationButtonActionPerformed
        try {
            saveChRegMatrixToFile(chRegTransformMethod, chRegMatrix);
        } catch (IOException e) {
            String msg = e.getMessage();
            IJ.error("Save error: " + msg);
        }
    }//GEN-LAST:event_saveRegistrationButtonActionPerformed

    private void calculateStichingButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calculateStichingButtonActionPerformed
        if (imageCount!=2){
            IJ.error("Requires two image stacks!");
            return;
        }
        if (topLeftImage != null) {
            if (topRightImage != null) {
                getStitchingTranslationMatrix(topLeftImage, topRightImage, maxXYshift, maxZshift, HORIZONTAL);
            } else if (bottomLeftImage != null) {
                getStitchingTranslationMatrix(topLeftImage, bottomLeftImage, maxXYshift, maxZshift, VERTICAL);
            } else {
                getStitchingTranslationMatrix(topLeftImage, bottomRightImage, maxXYshift, maxZshift, TLBR);
            }
        } else if (bottomLeftImage != null){
            if (topRightImage != null) {
                getStitchingTranslationMatrix(bottomLeftImage, topRightImage, maxXYshift, maxZshift, BLTR);
            } else{
                getStitchingTranslationMatrix(bottomLeftImage, bottomRightImage, maxXYshift, maxZshift, HORIZONTAL);
            }
        } else {
            getStitchingTranslationMatrix(topRightImage, bottomRightImage, maxXYshift, maxZshift, VERTICAL);
        }
    }//GEN-LAST:event_calculateStichingButtonActionPerformed
    private void getStitchingTranslationMatrix(ImagePlus refImg, ImagePlus algImg,
                    int maxXYshift, int maxZshift, String direction){
        if (refImg.getNChannels()!=algImg.getNChannels()){
            IJ.error("Images need to have the same channels !");
            return;
        }
        if (refImg.getRoi()==null || algImg.getRoi()==null){
            IJ.error("Please use point selection tool to point out corresponding positions in both images !");
            return;
        }
        if (refImg.getRoi().isArea() || refImg.getRoi().isLine() || 
                algImg.getRoi().isArea() || algImg.getRoi().isLine()){
            IJ.error("Please use point selection tool to point out corresponding positions in both images !");
            return;
        } 
        ImagePlus impWork = fc.getStackingRefAlgImg(refImg, algImg, maxXYshift, maxZshift);  
        double accuracy = 1;
        double[][] stitchingMatrix = fc.getNoMaskTranslateMatrix(impWork, 1, maxXYshift, maxZshift, accuracy);
        Rectangle refImgPoint = refImg.getRoi().getBounds();
        Rectangle algImgPoint = algImg.getRoi().getBounds();
        //IJ.log("refImgRoi x, y "+refImgPoint.x+", "+refImgPoint.y);
        //IJ.log("algImgRoi x, y "+algImgPoint.x+", "+algImgPoint.y);
        //IJ.log("input translation "+(int)stitchingMatrix[2][0]+", "+(int)stitchingMatrix[2][1]+", "+(int)stitchingMatrix[2][2]);
        int iteration = 0;
        int maxIteration = 3;
        while ((stitchingMatrix[2][0] != 0 || stitchingMatrix[2][1] != 0 || stitchingMatrix[2][2] != 0) && iteration<maxIteration) {
            algImg.setZ(algImg.getZ() - (int) stitchingMatrix[2][2]);
            algImgPoint = algImg.getRoi().getBounds();
            PointRoi newAlgImgPointRoi = new PointRoi(algImgPoint.x - (int) stitchingMatrix[2][0], algImgPoint.y - (int) stitchingMatrix[2][1]);
            algImg.setRoi(newAlgImgPointRoi);
            impWork = fc.getStackingRefAlgImg(refImg, algImg, maxXYshift, maxZshift);
            stitchingMatrix = fc.getNoMaskTranslateMatrix(impWork, 1, maxXYshift, maxZshift, accuracy);
            iteration++;
            //IJ.log("-------------------------");
            //IJ.log("algImgRoi x, y " + algImgPoint.x + ", " + algImgPoint.y);
            //IJ.log("after translation " + (int) stitchingMatrix[2][0] + ", " + (int) stitchingMatrix[2][1] + ", " + (int) stitchingMatrix[2][2]);
        }

        algImgPoint = algImg.getRoi().getBounds();   
        int xOffset = refImgPoint.x - algImgPoint.x;
        int yOffset = refImgPoint.y - algImgPoint.y;
        int zOffset = refImg.getZ() - algImg.getZ();

        // finalize stitching results
        updateStitchingResult(refImg, algImg, xOffset, yOffset, zOffset, stitchingMatrix[2][3], direction);
        impWork = fc.getStackingRefAlgImg(refImg, algImg, maxXYshift, maxZshift); 
        impWork.show();
        impWork.changes = false;
        //impWork.close();
    }
    private void stitchHorizontal(ImagePlus refImg, ImagePlus algImg, 
            int xOffset, int yOffset, int zOffset){
        if (refImg.getNChannels()!=algImg.getNChannels()){
            IJ.error("Images need to have the same channels !");
            return;
        }
        fc.stitchHorizontalMultiThread(refImg, algImg, xOffset, yOffset, zOffset);
        resetImages();
    }

    private void stitchVertical(ImagePlus refImg, ImagePlus algImg, 
            int xOffset, int yOffset, int zOffset){
        if (refImg.getNChannels()!=algImg.getNChannels()){
            IJ.error("Images need to have the same channels !");
            return;
        }
        fc.stitchVerticalMultiThread(refImg, algImg, xOffset, yOffset, zOffset);
        resetImages();
    }
        
    private void saveStitchingMatrixButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveStitchingMatrixButtonActionPerformed
        try {
            saveStichingToFile();
        } catch (IOException e) {
            String msg = e.getMessage();
            IJ.error("Save error: " + msg);
        }
    }//GEN-LAST:event_saveStitchingMatrixButtonActionPerformed

    private void loadStitchingMatrixButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadStitchingMatrixButtonActionPerformed
        try {
            parseStitchingFormFile();
        } catch (IOException e) {
        }
    }//GEN-LAST:event_loadStitchingMatrixButtonActionPerformed
    private void resetImages() {
        imageCount = 0;
        topLeftImage = null;
        topLeftImage_jToggleButton.setSelected(false);
        topLeftImage_jToggleButton.setToolTipText("");
        topRightImage = null;
        topRightImage_jToggleButton.setSelected(false);
        topRightImage_jToggleButton.setToolTipText("");
        bottomLeftImage = null;
        bottomLeftImage_jToggleButton.setSelected(false);
        bottomLeftImage_jToggleButton.setToolTipText("");
        bottomRightImage = null;
        bottomRightImage_jToggleButton.setSelected(false);
        bottomRightImage_jToggleButton.setToolTipText("");
    }
    private void topLeftImage_jToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_topLeftImage_jToggleButtonActionPerformed
        if (topLeftImage_jToggleButton.isSelected()){
            topLeftImage = WindowManager.getCurrentImage();
            if (topLeftImage == null){
                topLeftImage_jToggleButton.setSelected(false);
                topLeftImage_jToggleButton.setToolTipText("");
                return;
            }
            topLeftImage_jToggleButton.setToolTipText(topLeftImage.getTitle());
            imageCount++;
            if (imageCount>2){
                IJ.error("No more than two image can be aligned at the same time !\n\n"+
                        "Remove one image from panel before setting current one!");
                topLeftImage = null;
                topLeftImage_jToggleButton.setSelected(false);
                topLeftImage_jToggleButton.setToolTipText("");
                imageCount--;
            }
        } else {
            topLeftImage = null;
            topLeftImage_jToggleButton.setToolTipText("");
            imageCount--;
        }
    }//GEN-LAST:event_topLeftImage_jToggleButtonActionPerformed

    private void topRightImage_jToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_topRightImage_jToggleButtonActionPerformed
        if (topRightImage_jToggleButton.isSelected()){
            topRightImage = WindowManager.getCurrentImage();
            if (topRightImage == null){
                topRightImage_jToggleButton.setSelected(false);
                topRightImage_jToggleButton.setToolTipText("");
                return;
            }
            topRightImage_jToggleButton.setToolTipText(topRightImage.getTitle());
            imageCount++;
            if (imageCount>2){
                IJ.error("No more than two image can be aligned at the same time !\n\n"+
                        "Remove one image from panel before setting current one!");
                topRightImage = null;
                topRightImage_jToggleButton.setSelected(false);
                topRightImage_jToggleButton.setToolTipText("");
                imageCount--;
            }
        } else {
            topRightImage = null;
            topRightImage_jToggleButton.setToolTipText("");
            imageCount--;
        }
    }//GEN-LAST:event_topRightImage_jToggleButtonActionPerformed

    private void bottomLeftImage_jToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bottomLeftImage_jToggleButtonActionPerformed
        if (bottomLeftImage_jToggleButton.isSelected()){
            bottomLeftImage = WindowManager.getCurrentImage();
            if (bottomLeftImage == null){
                bottomLeftImage_jToggleButton.setSelected(false);
                bottomLeftImage_jToggleButton.setToolTipText("");
                return;
            }
            bottomLeftImage_jToggleButton.setToolTipText(bottomLeftImage.getTitle());
            imageCount++;
            if (imageCount>2){
                IJ.error("No more than two image can be aligned at the same time !\n\n"+
                        "Remove one image from panel before setting current one!");
                bottomLeftImage = null;
                bottomLeftImage_jToggleButton.setSelected(false);
                bottomLeftImage_jToggleButton.setToolTipText("");
                imageCount--;
            }
        } else {
            bottomLeftImage = null;
            bottomLeftImage_jToggleButton.setToolTipText("");
            imageCount--;
        }
    }//GEN-LAST:event_bottomLeftImage_jToggleButtonActionPerformed

    private void bottomRightImage_jToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bottomRightImage_jToggleButtonActionPerformed
        if (bottomRightImage_jToggleButton.isSelected()){
            bottomRightImage = WindowManager.getCurrentImage();
            if (bottomRightImage == null){
                bottomRightImage_jToggleButton.setSelected(false);
                bottomRightImage_jToggleButton.setToolTipText("");
                return;
            }
            bottomRightImage_jToggleButton.setToolTipText(bottomRightImage.getTitle());
            imageCount++;
            if (imageCount>2){
                IJ.error("No more than two image can be aligned at the same time !\n\n"+
                        "Remove one image from panel before setting current one!");
                bottomRightImage = null;
                bottomRightImage_jToggleButton.setSelected(false);
                bottomRightImage_jToggleButton.setToolTipText("");
                imageCount--;
            }
        } else {
            bottomRightImage = null;
            bottomRightImage_jToggleButton.setToolTipText("");
            imageCount--;
        }
    }//GEN-LAST:event_bottomRightImage_jToggleButtonActionPerformed

    private void manual_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_manual_jButtonActionPerformed
        showManual();
    }//GEN-LAST:event_manual_jButtonActionPerformed

    private void stitchOpenedButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stitchOpenedButtonActionPerformed
        String results = stitchingResult_jTextArea.getText();
        if (!results.startsWith("Stiching:")){
            IJ.error("No stitching offset results !");
            return;
        }
        String[] parameters = results.split("-----------------------------------------\n");
        String orientation = (parameters[0].split(" "))[1];
        String[] xyzOffset = parameters[1].split("\t");
        int xOffset = Integer.parseInt(xyzOffset[0]);
        int yOffset = Integer.parseInt(xyzOffset[1]);
        int zOffset = Integer.parseInt(xyzOffset[2]);
        
        if (imageCount!=2){
            IJ.error("Requires two image stacks!");
            return;
        }
        switch (orientation) {
            case HORIZONTAL:
                if (topLeftImage != null) {
                    if (topRightImage != null) {
                        stitchHorizontal(topLeftImage, topRightImage, xOffset, yOffset, zOffset);
                    } else {
                        IJ.error("Need to assign two horizontal images !");
                    }
                } else if (bottomLeftImage != null){
                    if (bottomRightImage != null) {
                        stitchHorizontal(bottomLeftImage, bottomRightImage, xOffset, yOffset, zOffset);
                    } else {
                        IJ.error("Need to assign two horizontal images !");
                    }
                }   break;
            case VERTICAL:
                if (topLeftImage != null) {
                    if (bottomLeftImage != null) {
                        stitchVertical(topLeftImage, bottomLeftImage, xOffset, yOffset, zOffset);
                    } else {
                        IJ.error("Need to assign two vertical images !");
                    }
                } else if (topRightImage != null){
                    if (bottomRightImage != null) {
                        stitchVertical(topRightImage, bottomRightImage, xOffset, yOffset, zOffset);
                    } else {
                        IJ.error("Need to assign two vertical images !");
                }
            }   break;
        }
    }//GEN-LAST:event_stitchOpenedButtonActionPerformed

    private void maxZshiftComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_maxZshiftComboBoxActionPerformed
        maxZshift = (Integer) ((maxZshiftComboBox.getSelectedIndex()+1) * 5);        
    }//GEN-LAST:event_maxZshiftComboBoxActionPerformed

    private void histogramMatchOpenedButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_histogramMatchOpenedButtonActionPerformed
        if (histogramRefImage == null){
            IJ.error("Select reference image !");
            return;
        }
        ImagePlus impTarget = WindowManager.getCurrentImage();
        matchImageHistogram(histogramRefImage, impTarget);
    }//GEN-LAST:event_histogramMatchOpenedButtonActionPerformed
    private void matchImageHistogram(ImagePlus histogramRefImage, ImagePlus impTarget){
        IJ.log("Histogram matching >> "+impTarget.getTitle());
        int targetType = impTarget.getType();
        if (!(targetType == ImagePlus.GRAY8 || targetType == ImagePlus.GRAY16 || targetType == ImagePlus.GRAY32)) {
            IJ.log("Abort - Gray scale image required!");
            return;
        }
        Duplicator dup = new Duplicator();
        ImagePlus impReference = dup.run(histogramRefImage, histogramRefImage.getC(), histogramRefImage.getC(),
                histogramRefImage.getZ(), histogramRefImage.getZ(), histogramRefImage.getT(), histogramRefImage.getT());
        if (targetType == ImagePlus.GRAY8) {
            IJ.run(impReference, "8-bit", "");
        } else if (targetType == ImagePlus.GRAY16) {
            IJ.run(impReference, "16-bit", "");
        } else if (targetType == ImagePlus.GRAY32) {
            IJ.run(impReference, "32-bit", "");
        }
        //impReference.show();
        ImageProcessor ipReference = impReference.getProcessor();
        double refMin = ipReference.getMin();
        double refMax = ipReference.getMax();
        // get histograms of both images
        int[] histogramReference = ipReference.getHistogram();
        ImageStack stkTarget = impTarget.getImageStack();
        //IJ.log("total n = "+stkTarget.getSize());
        //IJ.log("total processer = "+Runtime.getRuntime().availableProcessors());
        int threadNum = Runtime.getRuntime().availableProcessors() - 1;
        Thread[] threads = new Thread[threadNum];
        int totalSlices = stkTarget.getSize();
        int increament = (int) Math.ceil((double) totalSlices / (double) threadNum);
        //IJ.log("increament = "+increament);
        for (int i = 0; i < threadNum; i++) {
            int start = increament * i + 1;
            int end = increament * (i + 1) + 1;
            if (end > totalSlices) {
                end = totalSlices;
            }
            //IJ.log("i = "+i+"; start = "+start+" end = "+end);
            MatchHistogramThread matchHistogram
                    = new MatchHistogramThread(histogramReference, stkTarget, start, end);
            threads[i] = new Thread(matchHistogram);
            threads[i].start();
        }
        for (int i = 0; i < threadNum; i++) {
            try {
                threads[i].join();
            } catch (Exception e) {
                IJ.error(e.getMessage());
            }
        }
        impReference.close();
        impTarget.setStack(stkTarget);
        int currentC = impTarget.getC();
        for (int c = 1; c <= impTarget.getNChannels(); c++){
            impTarget.setC(c);
            IJ.setMinAndMax(impTarget, refMin, refMax);
        }
        impTarget.setC(currentC);
        impTarget.updateAndDraw();
        IJ.log("DONE !");
    }
    private void hmReferenceImage_jToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hmReferenceImage_jToggleButtonActionPerformed
        if (hmReferenceImage_jToggleButton.isSelected()){
            histogramRefImage = WindowManager.getCurrentImage();
            if (histogramRefImage == null){
                hmReferenceImage_jToggleButton.setSelected(false);
                hmReferenceImage_jToggleButton.setToolTipText("");
                return;
            }
            int type = histogramRefImage.getType();
            if (!(type == ImagePlus.GRAY8 || type == ImagePlus.GRAY16 || type == ImagePlus.GRAY32)) {
                IJ.error("Gray scale image required!");
                histogramRefImage = null;
                hmReferenceImage_jToggleButton.setSelected(false);
                hmReferenceImage_jToggleButton.setToolTipText("");
            }
            hmReferenceImage_jToggleButton.setToolTipText(histogramRefImage.getTitle());
        } else {
            histogramRefImage = null;
            hmReferenceImage_jToggleButton.setToolTipText("");
        }
    }//GEN-LAST:event_hmReferenceImage_jToggleButtonActionPerformed

    private void histogramMatchBatchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_histogramMatchBatchButtonActionPerformed
        if (histogramRefImage == null){
            IJ.error("Select reference image !");
            return;
        }
        DirectoryChooser dc = new DirectoryChooser("Choose a Folder ...");
        String selectedFolderPath = dc.getDirectory();
        if (selectedFolderPath != null) {
            batchHistogramMatching(histogramRefImage, selectedFolderPath);
        }
    }//GEN-LAST:event_histogramMatchBatchButtonActionPerformed

    private void translate_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_translate_jButtonActionPerformed
        int xShift = (int)Math.round(Double.parseDouble(xTranslation_jTextField.getText()));
        int yShift = (int)Math.round(Double.parseDouble(yTranslation_jTextField.getText()));
        int zShift = (int)Math.round(Double.parseDouble(zTranslation_jTextField.getText()));
        if (!(xShift >= 0 && yShift >= 0 && zShift >= 0)) {
            IJ.error("X, Y, Z shift needs to be integers >= 0");
            return;
        }
        if (xShift == 0 && yShift == 0 && zShift == 0) {
            IJ.error("Require translation in one of the X, Y, Z directions !");
            return;
        }
        String directory = IJ.getDirectory("current");
        final JFileChooser fChooser = new JFileChooser();
        fChooser.setSelectedFile(new File(directory + "/"));
        fChooser.setFileFilter(new javax.swing.filechooser.FileFilter() {
            @Override
            public boolean accept(File f) {
                if (f.isDirectory()) {
                    return true;
                }
                final String name = f.getName();
                return name.endsWith(".zip");
            }

            @Override
            public String getDescription() {
                return "*.zip";
            }
        });
        int returnVal = fChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.CANCEL_OPTION) {
            return;
        }
        File selectedFile = fChooser.getSelectedFile();
        try {
            translateTracingResult(xShift, yShift, zShift, selectedFile);
        } catch (IOException e) {
            IJ.error("Tracing result translation error: " + e);
        }
    }//GEN-LAST:event_translate_jButtonActionPerformed

    private void translateTracingResult(int xShift, int yShift, int zShift, 
            File selectedFile)throws IOException {
        String selectedPath = selectedFile.getAbsolutePath();
        String directory = selectedPath.substring(0, selectedPath.lastIndexOf(File.separator)+1);
        String newFileName = selectedPath.substring(selectedPath.lastIndexOf(File.separator)+1, selectedPath.length());
        if (directory == null || newFileName == null) {
            return;
        }
        if (newFileName.endsWith(".zip")){
            newFileName = newFileName.split(".zip")[0];
        }
        if (xShift > 0 || yShift > 0 || zShift > 0) {
            newFileName = newFileName + "_x" + (int) xShift + "-y" + (int) yShift + "-z" + (int) zShift;
        }
        newFileName = newFileName + ".zip";
        //IJ.log(directory + " : " + newFileName);
        String textFileName = newFileName.split(".zip")[0];
        ntIO IO = new ntIO();
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(directory + newFileName));
        DataOutputStream out = new DataOutputStream(new BufferedOutputStream(zos));

        try {
            // copy the status file
            InputStream expansionAndSelectionIS = IO.loadPackagedExpansionAndSelection(selectedFile);
            if (expansionAndSelectionIS != null) {
                zos.putNextEntry(new ZipEntry(textFileName + "-status.txt"));
                byte[] buffer = new byte[1024];
                int read;
                while ((read = expansionAndSelectionIS.read(buffer)) > 0) {
                    out.write(buffer, 0, read);
                }
            }
            out.flush();
        } catch (IOException e) {
        }
        try {
            // apply shift to tracing result file
            InputStream parameterAndNeuronIS = IO.loadPackagedParameterAndNeuron(selectedFile);
            if (parameterAndNeuronIS != null) {
                BufferedReader br = new BufferedReader(new InputStreamReader(parameterAndNeuronIS, "UTF-8"));
                Scanner ls = new Scanner(br);
                zos.putNextEntry(new ZipEntry(textFileName + "-data.txt"));
                while (ls.hasNext()) {
                    String lineRead = ls.nextLine();
                    if (lineRead.startsWith("POINT:")) {      
                        //IJ.log(lineRead);
                        String[] token = lineRead.split(" ");
                        int i = 0;
                        while (!(token[i].startsWith("END"))) {
                            if (token[i].equals("POINT:")) {
                                out.writeBytes(token[i] + " "); // write "POINT:"
                                i++;
                                out.writeBytes(token[i] + " "); // write "type"
                                i++;
                                out.writeBytes((Integer.parseInt(token[i])+xShift) + " "); // write translated "x"
                                i++;
                                out.writeBytes((Integer.parseInt(token[i])+yShift) + " "); // write translated "y"
                                i++;
                                out.writeBytes((Integer.parseInt(token[i])+zShift) + " "); // write translated "z"
                                i++;
                                out.writeBytes(token[i] + " "); // write "radius"
                                i++;
                                out.writeBytes(token[i] + " "); // write "synapse"
                                i++;                                
                                out.writeBytes(token[i] + " "); // write "connection"
                            }
                            i++;
                        }
                        out.writeBytes(token[i]);
                        out.writeBytes("\n");
                    } else {
                        out.writeBytes(lineRead);
                        out.writeBytes("\n");
                    }
                }
            }
            out.flush();
        } catch (IOException e) {
        } finally{
            out.close();
        } 
    }
    private void batchHistogramMatching(ImagePlus referenceImage, String folderPath) {
        File selectedFolder = new File(folderPath);
        String rootDirectory = selectedFolder.getAbsolutePath();
        IJ.log("Reference Image: "+referenceImage.getTitle());
        IJ.log("@ channel="+referenceImage.getC()+" @ slice="+referenceImage.getZ()+" @ frame="+referenceImage.getFrame());
        IJ.log("Histogram Matching Starting directory: " + rootDirectory + newline + newline);
        try {
            batchbatchHistogramMatchingSubfolder(referenceImage, selectedFolder, rootDirectory, histogramMatchSubfolderCheckBox.isSelected());
        } catch (IOException e) {
            IJ.log(e.getMessage() + newline + newline);
        }
    }
    private void batchbatchHistogramMatchingSubfolder(ImagePlus referenceImage, File selectedFolder,
            String rootDirectory, boolean histogramMatchSubfolder) throws IOException {
        File multFiles[] = selectedFolder.listFiles();
        ArrayList<File> tifFileList = new ArrayList<>();
        ArrayList<File> subfolderList = new ArrayList<>();
        for (File file : multFiles) {
            if (file.isFile()) {
                if (file.getName().endsWith(".tif") && !file.getName().endsWith("_hisMatch.tif")) {
                    tifFileList.add(file);
                }
            } else if (histogramMatchSubfolder) {
                subfolderList.add(file);
            }
        }

        tifFileList.stream().forEach((file) -> {
            String relative = (new File(rootDirectory)).toURI().relativize(file.toURI()).getPath();
            IJ.log("..\\" + relative);
            ImagePlus targetImage = IJ.openImage(file.getAbsolutePath());
            if (targetImage == null) {
                IJ.log("Image not opened !");
            } else {
                matchImageHistogram(referenceImage, targetImage);
                String title = targetImage.getTitle();
                if (title.endsWith(".tif")) {
                    title = title.substring(0, title.length() - 4);
                }
                targetImage.setTitle(title + "_hisMatch.tif");
                IJ.save(targetImage, new File(file.getAbsolutePath()).getParent() + "/" + targetImage.getTitle());
                targetImage.close();
                targetImage.flush();
            }
        });

        if (histogramMatchSubfolder) {
            for (File file : subfolderList) {
                IJ.log("");
                batchbatchHistogramMatchingSubfolder(referenceImage, file, rootDirectory, histogramMatchSubfolder);
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(() -> {
            new Align_Master().setVisible(true);
        });
    }

    // private methods
    private void showManual() {

    }

    private void updateStitchingResult(ImagePlus refImg, ImagePlus stcImg, 
            int xOffset, int yOffset, int zOffset, double correlation, String orientation) {
        stitchingResult_jTextArea.setText("Stiching: "+ orientation+" \n");
        stitchingResult_jTextArea.append("Reference Image: "+refImg.getTitle()+"\n");
        stitchingResult_jTextArea.append("Stitching Image: "+stcImg.getTitle()+"\n");
        stitchingResult_jTextArea.append("Pixel shift relative to reference (left) image\n");
        stitchingResult_jTextArea.append(
                "x-shift" + "\t"
                + "y-shift" + "\t"
                + "z-shift" + "\t"
                + "Cross Correlation"+ "\n");
        stitchingResult_jTextArea.append("-----------------------------------------");
            stitchingResult_jTextArea.append("\n");
            stitchingResult_jTextArea.append(
                    xOffset + "\t"
                    + yOffset + "\t"
                    + zOffset + "\t"
                    + correlation + "\n");
    }
    
    private void updateChRegResult(double[][] translationMatrix) {
        if (translationMatrix == null) {
            return;
        }

        int channels = translationMatrix.length - 1;
        chRegResult_jTextArea.setText(chRegTransformMethod + " -- total channels: " + channels);
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("Channel" + "\t"
                + "x-shift" + "\t"
                + "y-shift" + "\t"
                + "z-shift" + "\t"
                + "Cross Correlation");
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("-----------------------------------------");
        for (int n = 1; n <= channels; n++) {
            chRegResult_jTextArea.append("\n");
            chRegResult_jTextArea.append(n + "\t"
                    + translationMatrix[n][0] + "\t"
                    + translationMatrix[n][1] + "\t"
                    + translationMatrix[n][2] + "\t"
                    + translationMatrix[n][3]);
        }
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("----------------END------------------");
    }

    private void updateChRegResult(double[][][] transformMatrix) {
        if (transformMatrix == null) {
            return;
        }

        int channels = transformMatrix.length - 1;
        chRegResult_jTextArea.setText(chRegTransformMethod + " -- total channels: " + channels);
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("Channel");
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("-----------------------------------------");
        for (int n = 1; n <= channels; n++) {
            chRegResult_jTextArea.append("\n");
            chRegResult_jTextArea.append(n + "\n");
            for (int i = 0; i < 4; i++) {
                chRegResult_jTextArea.append(
                        transformMatrix[n][i][0] + "\t"
                        + transformMatrix[n][i][1] + "\t"
                        + transformMatrix[n][i][2] + "\t"
                        + transformMatrix[n][i][3] + "\n");
            }
        }
        chRegResult_jTextArea.append("\n");
        chRegResult_jTextArea.append("----------------END------------------");
    }

    private void saveStichingToFile() throws IOException {
        try {
            String resultText = stitchingResult_jTextArea.getText();
            if (!resultText.startsWith("Stiching:")) {
                return;
            }
            SimpleDateFormat fileFormatter = new SimpleDateFormat("MMddHHmm");
            Date now = new Date();
            String timeLabel = fileFormatter.format(now);
            String resultFileName = (String) ("Stitching_"+ (resultText.split(" ")[1])+"_"+ timeLabel+".txt");
            //IJ.log(resultFileName);
            SaveDialog sd = new SaveDialog("Save result as ...", IJ.getDirectory("current"), resultFileName, ".txt");
            String outputPath = sd.getDirectory();
            resultFileName = sd.getFileName();
            if (outputPath == null || resultFileName == null) {
                return;
            }
            File resultFile = new File(outputPath, resultFileName);
            fileWriter = new FileWriter(resultFile);
            bufferedWriter = new BufferedWriter(fileWriter);
            bufferedWriter.write(resultText);
        } finally {
            if (bufferedWriter != null) {
                bufferedWriter.close();
            }
            if (fileWriter != null) {
                fileWriter.close();
            }
        }
    }
    private void parseStitchingFormFile() throws IOException {
        try {
            OpenDialog od = new OpenDialog("Load alignment matrix ...", "");
            String dir = od.getDirectory();
            String name = od.getFileName();
            if (dir == null || name == null) {
                return;
            }
            File resultFile = new File(dir, name);
            // What to do with the file, e.g. display it in a TextArea
            fileReader = new FileReader(resultFile);
            bufferedReader = new BufferedReader(fileReader);
            loadScanner = new Scanner(bufferedReader);
            stitchingResult_jTextArea.setText("");
            while (loadScanner.hasNext()) {
                stitchingResult_jTextArea.append(loadScanner.nextLine());
                stitchingResult_jTextArea.append("\n");
            } // end loading parameters
        } catch (IOException e) {
            IJ.error("Load error: " + e.getMessage());
        } finally {
            if (bufferedWriter != null) {
                bufferedWriter.close();
            }
            if (fileReader != null) {
                fileReader.close();
            }
            if (loadScanner != null) {
                loadScanner.close();
            }
        }
    }

    private void saveChRegMatrixToFile(String transform, double[][] matrix)
            throws IOException {
        try {
            if (matrix == null) {
                return;
            }
            int channels = matrix.length - 1;
            SimpleDateFormat fileFormatter = new SimpleDateFormat("MMddHHmm");
            Date now = new Date();
            String timeLabel = fileFormatter.format(now);
            String resultFileName = (String) ("Channel Registration_" + timeLabel + ".txt");
            SaveDialog sd = new SaveDialog("Save result as ...", IJ.getDirectory("current"), resultFileName, ".txt");
            String outputPath = sd.getDirectory();
            resultFileName = sd.getFileName();
            if (outputPath == null || resultFileName == null) {
                return;
            }
            File resultFile = new File(outputPath, resultFileName);
            fileWriter = new FileWriter(resultFile);
            bufferedWriter = new BufferedWriter(fileWriter);
            // Column names
            bufferedWriter.write(transform + " -- total channels: " + channels);

            if (transform.equals("Translation")) {
                bufferedWriter.newLine();
                bufferedWriter.newLine();
                bufferedWriter.write("Channel" + "\t"
                        + "x-shift" + "\t"
                        + "y-shift" + "\t"
                        + "z-shift" + "\t"
                        + "Cross Correlation");
                bufferedWriter.newLine();
                bufferedWriter.write("-----------------------------------------");
                for (int n = 1; n <= channels; n++) {
                    bufferedWriter.newLine();
                    bufferedWriter.write(n + "\t"
                            + matrix[n][0] + "\t"
                            + matrix[n][1] + "\t"
                            + matrix[n][2] + "\t"
                            + matrix[n][3]);
                }
            }
            if (transform.equals("Rigid Body")) {
            }
            if (transform.equals("Scale")) {
            }
            if (transform.equals("Affine")) {
            }
            bufferedWriter.newLine();
            bufferedWriter.write("----------------END------------------");
        } finally {
            if (bufferedWriter != null) {
                bufferedWriter.close();
            }
            if (fileWriter != null) {
                fileWriter.close();
            }
        }
    }

    private double[][] parseChRegMatrixformFile() throws IOException {
        try {
            double[][] matrix = null;
            OpenDialog od = new OpenDialog("Load alignment matrix ...", "");
            String dir = od.getDirectory();
            String name = od.getFileName();
            if (dir == null || name == null) {
                return null;
            }
            File resultFile = new File(dir, name);

            // What to do with the file, e.g. display it in a TextArea
            fileReader = new FileReader(resultFile);
            bufferedReader = new BufferedReader(fileReader);
            loadScanner = new Scanner(bufferedReader);
            //resultTextArea.read(fileReader, null);
            while (loadScanner.hasNext()) {
                String s = loadScanner.next();
                if (s.equals("Translation")) {
                    while (loadScanner.hasNext()) {
                        String t = loadScanner.next();
                        if (t.endsWith(":")) {
                            int totalCH = loadScanner.nextInt();
                            matrix = new double[totalCH + 1][4];
                            for (int i = 0; i < 4; i++) {
                                matrix[0][i] = 0;
                            }
                            while (loadScanner.hasNext()) {
                                String u = loadScanner.next();
                                if (u.equals("-----------------------------------------")) {
                                    while (loadScanner.hasNext()) {
                                        String v = loadScanner.next();
                                        if (v.equals("----------------END------------------")) {
                                            break;
                                        }
                                        int ch = Integer.parseInt(v);
                                        for (int j = 0; j < 4; j++) {
                                            matrix[ch][j] = loadScanner.nextDouble();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } // end loading parameters
            return matrix;
        } catch (IOException e) {
            IJ.error("Load error: " + e.getMessage());
            return null;
        } finally {
            if (bufferedWriter != null) {
                bufferedWriter.close();
            }
            if (fileReader != null) {
                fileReader.close();
            }
            if (loadScanner != null) {
                loadScanner.close();
            }
        }
    }

    // public methods
    public double getMaxShift() {
        return maxXYshift;
    }

    public double getMaxZ() {
        return maxZshift;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTabbedPane action_jTabbedPane;
    private javax.swing.JToggleButton bottomLeftImage_jToggleButton;
    private javax.swing.JToggleButton bottomRightImage_jToggleButton;
    private javax.swing.JButton calculateRegistrationButton;
    private javax.swing.JButton calculateStichingButton;
    private javax.swing.JTextArea chRegResult_jTextArea;
    private javax.swing.JPanel colorNormalization_jPanel;
    private javax.swing.JFileChooser fileChooser;
    private javax.swing.JCheckBox highContrast_jCheckBox;
    private javax.swing.JButton histogramMatchBatchButton;
    private javax.swing.JButton histogramMatchOpenedButton;
    private javax.swing.JCheckBox histogramMatchSubfolderCheckBox;
    private javax.swing.JPanel histogramMatching_jPanel;
    private javax.swing.JPanel hmParameter_jPanel;
    private javax.swing.JToggleButton hmReferenceImage_jToggleButton;
    private javax.swing.JButton loadRegistrationButton;
    private javax.swing.JButton loadStitchingMatrixButton;
    private javax.swing.JButton manual_jButton;
    private javax.swing.JComboBox maxXYshiftComboBox;
    private javax.swing.JLabel maxXYshiftLabel;
    private javax.swing.JComboBox maxZshiftComboBox;
    private javax.swing.JLabel maxZshiftLabel;
    private javax.swing.JLabel pixelShiftLabel2;
    private javax.swing.JButton registerBatchButton;
    private javax.swing.JButton registerOpenedButton;
    private javax.swing.JCheckBox registerSubfolderCheckBox;
    private javax.swing.JPanel register_jPanel;
    private javax.swing.JPanel registrationMatrix_jPanel;
    private javax.swing.JPanel registration_jPanel;
    private javax.swing.JScrollPane result_jScrollPane;
    private javax.swing.JButton saveRegistrationButton;
    private javax.swing.JButton saveStitchingMatrixButton;
    private javax.swing.JButton stitchOpenedButton;
    private javax.swing.JScrollPane stitchingResult_jScrollPane;
    private javax.swing.JTextArea stitchingResult_jTextArea;
    private javax.swing.JPanel stitching_jPanel;
    private javax.swing.JToggleButton topLeftImage_jToggleButton;
    private javax.swing.JToggleButton topRightImage_jToggleButton;
    private javax.swing.JPanel translateResult_jPanel;
    private javax.swing.JButton translate_jButton;
    private javax.swing.JLabel xPixels_jLabel;
    private javax.swing.JLabel xTranslation_jLabel;
    private javax.swing.JTextField xTranslation_jTextField;
    private javax.swing.JLabel yPixels_jLabel;
    private javax.swing.JLabel yTranslation_jLabel;
    private javax.swing.JTextField yTranslation_jTextField;
    private javax.swing.JLabel zPixels_jLabel;
    private javax.swing.JLabel zTranslation_jLabel;
    private javax.swing.JTextField zTranslation_jTextField;
    // End of variables declaration//GEN-END:variables
    private FileWriter fileWriter;
    private BufferedWriter bufferedWriter;
    private FileReader fileReader;
    private BufferedReader bufferedReader;
    private Scanner loadScanner;
    private final AMfunctions fc;
    private String chRegTransformMethod = "Translation";
    private static final String HORIZONTAL = "Left-Right";
    private static final String VERTICAL = "Top-Bottom";
    private static final String BLTR = "BottomLeft-TopRight";
    private static final String TLBR = "TopLeft-BottomRight";
    private int maxXYshift, maxZshift;
    private double[][] chRegMatrix; //[channel][4]x-y-z shift, cross-correlation
    private double[][][] transformMatrix; //[channel],[4][4]3D-transform matrix
    private ImagePlus topLeftImage, topRightImage, bottomLeftImage, bottomRightImage, histogramRefImage;
    private int imageCount = 0;
    static private final String newline = "\n";

    class MatchHistogramThread extends Thread {
        int[] histogramReference;
        ImageStack stkTarget;
        int start, end;

        public MatchHistogramThread(int[] histogramReference, ImageStack stkTarget, int start, int end) {
            this.histogramReference = histogramReference;
            this.stkTarget = stkTarget;
            this.start = start;
            this.end = end;
        }

        @Override
        public void run() {
            double[] referenceCDF = getCDF(histogramReference); // get CDF of histogram hR
            for (int n = start; n <= end; n++) {
                ImageProcessor ipTarget = stkTarget.getProcessor(n);
                int[] histogramTargete = ipTarget.getHistogram();
                int[] pixelMappingFunction = matchHistograms(histogramTargete, referenceCDF);
                ipTarget.applyTable(pixelMappingFunction);
                stkTarget.setProcessor(ipTarget, n);
            }
        }

        private int[] matchHistograms(int[] histogramTargete, double[] referenceCDF) {
            double[] targetCDF = getCDF(histogramTargete); // get CDF of target histogram
            int[] pixelMappingFunction = new int[histogramTargete.length]; // pixel mapping function f()

            // compute pixel mapping function f():
            for (int a = 0; a < histogramTargete.length; a++) {
                int j = histogramTargete.length - 1;
                do {
                    pixelMappingFunction[a] = j;
                    j--;
                } while (j >= 0 && targetCDF[a] <= referenceCDF[j]);
            }
            return pixelMappingFunction;
        }

	private double[] getCDF (int[] h) {
		// returns the cumul. probability distribution function (cdf) for histogram h
		int n = 0;		// sum all histogram values		
		for (int i=0; i<h.length; i++)	{ 	
			n = n + h[i]; 
		}
		double[] P = new double[h.length];
		int c = h[0];
		P[0] = (double) c / n;
		for (int i = 1; i < h.length; i++) {
	    	c = c + h[i];
	        P[i] = (double) c / n;
	    }
	    return P;
	}
    }

}
